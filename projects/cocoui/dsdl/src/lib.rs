/*
 * UAVCAN data structure definition for canars.
 *
 * Autogenerated, do not edit.
 */

extern crate canars;

use canars::RxTransfer;

pub mod uavcan {
pub mod protocol {

#[derive(Debug)]
pub struct HardwareVersion {
  // FieldTypes
    major: u8, // bit len 8
    minor: u8, // bit len 8
    unique_id: [u8; 16], // Static Array 8bit[16] max items
    certificate_of_authenticity: Vec<u8>, // Dynamic Array 8bit[255] max items

}

impl HardwareVersion {
  const SIGNATURE: u64 = 0xAD5C4C933F4A0C4;

  pub fn set_signature(signature: &mut u64){
    *signature = HardwareVersion::SIGNATURE;
  }

  pub fn decode(xfer: &::RxTransfer) -> Option<HardwareVersion> {
    /* Backward compatibility support for removing TAO
     *  - first try to decode with TAO DISABLED
     *  - if it fails fall back to TAO ENABLED
     */
    let mut offset = 0;
    let mut r = HardwareVersion::decode_internal(xfer, &mut offset, false);
    if r.is_none() {
      offset = 0;
      r = HardwareVersion::decode_internal(xfer, &mut offset, true);
    }
    r
  }

  fn decode_internal(xfer: &::RxTransfer, offset: &mut usize, tao: bool) -> Option<HardwareVersion> {
    let mut offset = offset;
    let major = match xfer.decode_scalar_u8(offset, 8) {
     Some(s) => s,
     None => return None,
    };
    let minor = match xfer.decode_scalar_u8(offset, 8) {
     Some(s) => s,
     None => return None,
    };
    // Static array (unique_id)
    let mut unique_id = [0 as u8; 16];
    for c in 0..16 {
      unique_id[c] = match xfer.decode_scalar_u8(offset, 8) {
       Some(s) => s,
       None => return None,
      };
    }

    let certificate_of_authenticity_len;
    //  - Last item in struct & Root item & (Array Size > 8 bit), tail array optimization
    if xfer.get_payload_len() > 0 && tao {
      //  - Calculate Array length from MSG length
      certificate_of_authenticity_len = ((xfer.get_payload_len() as usize * 8) - *offset) / 8; // 8 bit array item size
    }
    else {
      // - Array length 8 bits
      certificate_of_authenticity_len = match xfer.decode_scalar_u8(offset, 8) {
       Some(s) => s as usize,
       None => return None,
      };
    }
    let mut certificate_of_authenticity = Vec::new();
    for _c in 0..certificate_of_authenticity_len {
      let data = match xfer.decode_scalar_u8(offset, 8) {
        Some(s) => s,
        None => return None,
      };
      certificate_of_authenticity.push(data);
    }
    //  - Get Array

    Some(HardwareVersion {
      major,
      minor,
      unique_id,
      certificate_of_authenticity,
    })
  }

}

#[derive(Debug)]
pub struct DataTypeKind {
  // FieldTypes
    value: u8, // bit len 8

}

impl DataTypeKind {
  const SIGNATURE: u64 = 0x9420A73E008E5930;

  pub fn set_signature(signature: &mut u64){
    *signature = DataTypeKind::SIGNATURE;
  }

  pub fn decode(xfer: &::RxTransfer) -> Option<DataTypeKind> {
    /* Backward compatibility support for removing TAO
     *  - first try to decode with TAO DISABLED
     *  - if it fails fall back to TAO ENABLED
     */
    let mut offset = 0;
    let mut r = DataTypeKind::decode_internal(xfer, &mut offset, false);
    if r.is_none() {
      offset = 0;
      r = DataTypeKind::decode_internal(xfer, &mut offset, true);
    }
    r
  }

  fn decode_internal(xfer: &::RxTransfer, offset: &mut usize, tao: bool) -> Option<DataTypeKind> {
    let mut offset = offset;
    let value = match xfer.decode_scalar_u8(offset, 8) {
     Some(s) => s,
     None => return None,
    };

    Some(DataTypeKind {
      value,
    })
  }

}

#[derive(Debug)]
pub struct GetNodeInfoRequest {
  // FieldTypes

}

impl GetNodeInfoRequest {
  const ID: u16 = 1;
  const SIGNATURE: u64 = 0xEE468A8121C46A9E;

  pub fn check_id(data_type: u16) -> bool {
    data_type == GetNodeInfoRequest::ID
  }

  pub fn set_signature(signature: &mut u64){
    *signature = GetNodeInfoRequest::SIGNATURE;
  }

  pub fn decode(xfer: &::RxTransfer) -> Option<GetNodeInfoRequest> {
    /* Backward compatibility support for removing TAO
     *  - first try to decode with TAO DISABLED
     *  - if it fails fall back to TAO ENABLED
     */
    let mut offset = 0;
    let mut r = GetNodeInfoRequest::decode_internal(xfer, &mut offset, false);
    if r.is_none() {
      offset = 0;
      r = GetNodeInfoRequest::decode_internal(xfer, &mut offset, true);
    }
    r
  }

  fn decode_internal(xfer: &::RxTransfer, offset: &mut usize, tao: bool) -> Option<GetNodeInfoRequest> {
    let mut offset = offset;

    Some(GetNodeInfoRequest {
    })
  }

}

#[derive(Debug)]
pub struct GetNodeInfoResponse {
  // FieldTypes
    status: ::uavcan::protocol::NodeStatus, //
    software_version: ::uavcan::protocol::SoftwareVersion, //
    hardware_version: ::uavcan::protocol::HardwareVersion, //
    name: Vec<u8>, // Dynamic Array 8bit[80] max items

}

impl GetNodeInfoResponse {
  const ID: u16 = 1;
  const SIGNATURE: u64 = 0xEE468A8121C46A9E;

  pub fn check_id(data_type: u16) -> bool {
    data_type == GetNodeInfoResponse::ID
  }

  pub fn set_signature(signature: &mut u64){
    *signature = GetNodeInfoResponse::SIGNATURE;
  }

  pub fn decode(xfer: &::RxTransfer) -> Option<GetNodeInfoResponse> {
    /* Backward compatibility support for removing TAO
     *  - first try to decode with TAO DISABLED
     *  - if it fails fall back to TAO ENABLED
     */
    let mut offset = 0;
    let mut r = GetNodeInfoResponse::decode_internal(xfer, &mut offset, false);
    if r.is_none() {
      offset = 0;
      r = GetNodeInfoResponse::decode_internal(xfer, &mut offset, true);
    }
    r
  }

  fn decode_internal(xfer: &::RxTransfer, offset: &mut usize, tao: bool) -> Option<GetNodeInfoResponse> {
    let mut offset = offset;
    let status = match ::uavcan::protocol::NodeStatus::decode_internal(xfer, offset, tao) {
      Some(s) => s,
      None => return None,
    };
    let software_version = match ::uavcan::protocol::SoftwareVersion::decode_internal(xfer, offset, tao) {
      Some(s) => s,
      None => return None,
    };
    let hardware_version = match ::uavcan::protocol::HardwareVersion::decode_internal(xfer, offset, tao) {
      Some(s) => s,
      None => return None,
    };
    let name_len;
    //  - Last item in struct & Root item & (Array Size > 8 bit), tail array optimization
    if xfer.get_payload_len() > 0 && tao {
      //  - Calculate Array length from MSG length
      name_len = ((xfer.get_payload_len() as usize * 8) - *offset) / 8; // 8 bit array item size
    }
    else {
      // - Array length 7 bits
      name_len = match xfer.decode_scalar_u8(offset, 7) {
       Some(s) => s as usize,
       None => return None,
      };
    }
    let mut name = Vec::new();
    for _c in 0..name_len {
      let data = match xfer.decode_scalar_u8(offset, 8) {
        Some(s) => s,
        None => return None,
      };
      name.push(data);
    }
    //  - Get Array

    Some(GetNodeInfoResponse {
      status,
      software_version,
      hardware_version,
      name,
    })
  }

}

#[derive(Debug)]
pub struct RestartNodeRequest {
  // FieldTypes
    magic_number: u64, // bit len 40

}

impl RestartNodeRequest {
  const ID: u16 = 5;
  const SIGNATURE: u64 = 0x569E05394A3017F0;

  pub fn check_id(data_type: u16) -> bool {
    data_type == RestartNodeRequest::ID
  }

  pub fn set_signature(signature: &mut u64){
    *signature = RestartNodeRequest::SIGNATURE;
  }

  pub fn decode(xfer: &::RxTransfer) -> Option<RestartNodeRequest> {
    /* Backward compatibility support for removing TAO
     *  - first try to decode with TAO DISABLED
     *  - if it fails fall back to TAO ENABLED
     */
    let mut offset = 0;
    let mut r = RestartNodeRequest::decode_internal(xfer, &mut offset, false);
    if r.is_none() {
      offset = 0;
      r = RestartNodeRequest::decode_internal(xfer, &mut offset, true);
    }
    r
  }

  fn decode_internal(xfer: &::RxTransfer, offset: &mut usize, tao: bool) -> Option<RestartNodeRequest> {
    let mut offset = offset;
    let magic_number = match xfer.decode_scalar_u64(offset, 40) {
     Some(s) => s,
     None => return None,
    };

    Some(RestartNodeRequest {
      magic_number,
    })
  }

}

#[derive(Debug)]
pub struct RestartNodeResponse {
  // FieldTypes
    ok: bool, // bit len 1

}

impl RestartNodeResponse {
  const ID: u16 = 5;
  const SIGNATURE: u64 = 0x569E05394A3017F0;

  pub fn check_id(data_type: u16) -> bool {
    data_type == RestartNodeResponse::ID
  }

  pub fn set_signature(signature: &mut u64){
    *signature = RestartNodeResponse::SIGNATURE;
  }

  pub fn decode(xfer: &::RxTransfer) -> Option<RestartNodeResponse> {
    /* Backward compatibility support for removing TAO
     *  - first try to decode with TAO DISABLED
     *  - if it fails fall back to TAO ENABLED
     */
    let mut offset = 0;
    let mut r = RestartNodeResponse::decode_internal(xfer, &mut offset, false);
    if r.is_none() {
      offset = 0;
      r = RestartNodeResponse::decode_internal(xfer, &mut offset, true);
    }
    r
  }

  fn decode_internal(xfer: &::RxTransfer, offset: &mut usize, tao: bool) -> Option<RestartNodeResponse> {
    let mut offset = offset;
    let ok = match xfer.decode_scalar_bool(offset, 1) {
     Some(s) => s,
     None => return None,
    };

    Some(RestartNodeResponse {
      ok,
    })
  }

}

#[derive(Debug)]
pub struct SoftwareVersion {
  // FieldTypes
    major: u8, // bit len 8
    minor: u8, // bit len 8
    optional_field_flags: u8, // bit len 8
    vcs_commit: u32, // bit len 32
    image_crc: u64, // bit len 64

}

impl SoftwareVersion {
  const SIGNATURE: u64 = 0xDD46FD376527FEA1;

  pub fn set_signature(signature: &mut u64){
    *signature = SoftwareVersion::SIGNATURE;
  }

  pub fn decode(xfer: &::RxTransfer) -> Option<SoftwareVersion> {
    /* Backward compatibility support for removing TAO
     *  - first try to decode with TAO DISABLED
     *  - if it fails fall back to TAO ENABLED
     */
    let mut offset = 0;
    let mut r = SoftwareVersion::decode_internal(xfer, &mut offset, false);
    if r.is_none() {
      offset = 0;
      r = SoftwareVersion::decode_internal(xfer, &mut offset, true);
    }
    r
  }

  fn decode_internal(xfer: &::RxTransfer, offset: &mut usize, tao: bool) -> Option<SoftwareVersion> {
    let mut offset = offset;
    let major = match xfer.decode_scalar_u8(offset, 8) {
     Some(s) => s,
     None => return None,
    };
    let minor = match xfer.decode_scalar_u8(offset, 8) {
     Some(s) => s,
     None => return None,
    };
    let optional_field_flags = match xfer.decode_scalar_u8(offset, 8) {
     Some(s) => s,
     None => return None,
    };
    let vcs_commit = match xfer.decode_scalar_u32(offset, 32) {
     Some(s) => s,
     None => return None,
    };
    let image_crc = match xfer.decode_scalar_u64(offset, 64) {
     Some(s) => s,
     None => return None,
    };

    Some(SoftwareVersion {
      major,
      minor,
      optional_field_flags,
      vcs_commit,
      image_crc,
    })
  }

}

#[derive(Debug)]
pub struct NodeStatus {
  // FieldTypes
    uptime_sec: u32, // bit len 32
    health: u8, // bit len 2
    mode: u8, // bit len 3
    sub_mode: u8, // bit len 3
    vendor_specific_status_code: u16, // bit len 16

}

impl NodeStatus {
  const ID: u16 = 341;
  const SIGNATURE: u64 = 0xF0868D0C1A7C6F1;

  pub fn check_id(data_type: u16) -> bool {
    data_type == NodeStatus::ID
  }

  pub fn set_signature(signature: &mut u64){
    *signature = NodeStatus::SIGNATURE;
  }

  pub fn decode(xfer: &::RxTransfer) -> Option<NodeStatus> {
    /* Backward compatibility support for removing TAO
     *  - first try to decode with TAO DISABLED
     *  - if it fails fall back to TAO ENABLED
     */
    let mut offset = 0;
    let mut r = NodeStatus::decode_internal(xfer, &mut offset, false);
    if r.is_none() {
      offset = 0;
      r = NodeStatus::decode_internal(xfer, &mut offset, true);
    }
    r
  }

  fn decode_internal(xfer: &::RxTransfer, offset: &mut usize, tao: bool) -> Option<NodeStatus> {
    let mut offset = offset;
    let uptime_sec = match xfer.decode_scalar_u32(offset, 32) {
     Some(s) => s,
     None => return None,
    };
    let health = match xfer.decode_scalar_u8(offset, 2) {
     Some(s) => s,
     None => return None,
    };
    let mode = match xfer.decode_scalar_u8(offset, 3) {
     Some(s) => s,
     None => return None,
    };
    let sub_mode = match xfer.decode_scalar_u8(offset, 3) {
     Some(s) => s,
     None => return None,
    };
    let vendor_specific_status_code = match xfer.decode_scalar_u16(offset, 16) {
     Some(s) => s,
     None => return None,
    };

    Some(NodeStatus {
      uptime_sec,
      health,
      mode,
      sub_mode,
      vendor_specific_status_code,
    })
  }

}

#[derive(Debug)]
pub struct GetDataTypeInfoRequest {
  // FieldTypes
    id: u16, // bit len 16
    kind: ::uavcan::protocol::DataTypeKind, //
    name: Vec<u8>, // Dynamic Array 8bit[80] max items

}

impl GetDataTypeInfoRequest {
  const ID: u16 = 2;
  const SIGNATURE: u64 = 0x1B283338A7BED2D8;

  pub fn check_id(data_type: u16) -> bool {
    data_type == GetDataTypeInfoRequest::ID
  }

  pub fn set_signature(signature: &mut u64){
    *signature = GetDataTypeInfoRequest::SIGNATURE;
  }

  pub fn decode(xfer: &::RxTransfer) -> Option<GetDataTypeInfoRequest> {
    /* Backward compatibility support for removing TAO
     *  - first try to decode with TAO DISABLED
     *  - if it fails fall back to TAO ENABLED
     */
    let mut offset = 0;
    let mut r = GetDataTypeInfoRequest::decode_internal(xfer, &mut offset, false);
    if r.is_none() {
      offset = 0;
      r = GetDataTypeInfoRequest::decode_internal(xfer, &mut offset, true);
    }
    r
  }

  fn decode_internal(xfer: &::RxTransfer, offset: &mut usize, tao: bool) -> Option<GetDataTypeInfoRequest> {
    let mut offset = offset;
    let id = match xfer.decode_scalar_u16(offset, 16) {
     Some(s) => s,
     None => return None,
    };
    let kind = match ::uavcan::protocol::DataTypeKind::decode_internal(xfer, offset, tao) {
      Some(s) => s,
      None => return None,
    };
    let name_len;
    //  - Last item in struct & Root item & (Array Size > 8 bit), tail array optimization
    if xfer.get_payload_len() > 0 && tao {
      //  - Calculate Array length from MSG length
      name_len = ((xfer.get_payload_len() as usize * 8) - *offset) / 8; // 8 bit array item size
    }
    else {
      // - Array length 7 bits
      name_len = match xfer.decode_scalar_u8(offset, 7) {
       Some(s) => s as usize,
       None => return None,
      };
    }
    let mut name = Vec::new();
    for _c in 0..name_len {
      let data = match xfer.decode_scalar_u8(offset, 8) {
        Some(s) => s,
        None => return None,
      };
      name.push(data);
    }
    //  - Get Array

    Some(GetDataTypeInfoRequest {
      id,
      kind,
      name,
    })
  }

}

#[derive(Debug)]
pub struct GetDataTypeInfoResponse {
  // FieldTypes
    signature: u64, // bit len 64
    id: u16, // bit len 16
    kind: ::uavcan::protocol::DataTypeKind, //
    flags: u8, // bit len 8
    name: Vec<u8>, // Dynamic Array 8bit[80] max items

}

impl GetDataTypeInfoResponse {
  const ID: u16 = 2;
  const SIGNATURE: u64 = 0x1B283338A7BED2D8;

  pub fn check_id(data_type: u16) -> bool {
    data_type == GetDataTypeInfoResponse::ID
  }

  pub fn set_signature(signature: &mut u64){
    *signature = GetDataTypeInfoResponse::SIGNATURE;
  }

  pub fn decode(xfer: &::RxTransfer) -> Option<GetDataTypeInfoResponse> {
    /* Backward compatibility support for removing TAO
     *  - first try to decode with TAO DISABLED
     *  - if it fails fall back to TAO ENABLED
     */
    let mut offset = 0;
    let mut r = GetDataTypeInfoResponse::decode_internal(xfer, &mut offset, false);
    if r.is_none() {
      offset = 0;
      r = GetDataTypeInfoResponse::decode_internal(xfer, &mut offset, true);
    }
    r
  }

  fn decode_internal(xfer: &::RxTransfer, offset: &mut usize, tao: bool) -> Option<GetDataTypeInfoResponse> {
    let mut offset = offset;
    let signature = match xfer.decode_scalar_u64(offset, 64) {
     Some(s) => s,
     None => return None,
    };
    let id = match xfer.decode_scalar_u16(offset, 16) {
     Some(s) => s,
     None => return None,
    };
    let kind = match ::uavcan::protocol::DataTypeKind::decode_internal(xfer, offset, tao) {
      Some(s) => s,
      None => return None,
    };
    let flags = match xfer.decode_scalar_u8(offset, 8) {
     Some(s) => s,
     None => return None,
    };
    let name_len;
    //  - Last item in struct & Root item & (Array Size > 8 bit), tail array optimization
    if xfer.get_payload_len() > 0 && tao {
      //  - Calculate Array length from MSG length
      name_len = ((xfer.get_payload_len() as usize * 8) - *offset) / 8; // 8 bit array item size
    }
    else {
      // - Array length 7 bits
      name_len = match xfer.decode_scalar_u8(offset, 7) {
       Some(s) => s as usize,
       None => return None,
      };
    }
    let mut name = Vec::new();
    for _c in 0..name_len {
      let data = match xfer.decode_scalar_u8(offset, 8) {
        Some(s) => s,
        None => return None,
      };
      name.push(data);
    }
    //  - Get Array

    Some(GetDataTypeInfoResponse {
      signature,
      id,
      kind,
      flags,
      name,
    })
  }

}

}
}
