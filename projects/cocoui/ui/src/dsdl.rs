# [ allow ( unused_imports ) ] # [ macro_use ] extern crate uavcan as uavcan_rs ; # [ allow ( unused_imports ) ] pub ( crate ) use uavcan_rs :: types :: * ; pub mod uavcan { pub mod protocol { # [ doc = "" ] # [ doc = " Restart the node." ] # [ doc = "" ] # [ doc = " Some nodes may require restart before the new configuration will be applied." ] # [ doc = "" ] # [ doc = " The request should be rejected if magic_number does not equal MAGIC_NUMBER." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x569e05394a3017f0" ] pub struct RestartNodeRequest { pub magic_number : :: u40 } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x569e05394a3017f0" ] pub struct RestartNodeResponse { pub ok : bool } impl :: uavcan_rs :: Request for RestartNodeRequest { type RESPONSE = RestartNodeResponse ; const TYPE_ID : Option < u8 > = Some ( 5 ) ; } impl :: uavcan_rs :: Response for RestartNodeResponse { type REQUEST = RestartNodeRequest ; const TYPE_ID : Option < u8 > = Some ( 5 ) ; } # [ doc = "" ] # [ doc = " Get the implementation details of a given data type." ] # [ doc = "" ] # [ doc = " Request is interpreted as follows:" ] # [ doc = "  - If the field 'name' is empty, the fields 'kind' and 'id' will be used to identify the data type." ] # [ doc = "  - If the field 'name' is non-empty, it will be used to identify the data type; the" ] # [ doc = "    fields 'kind' and 'id' will be ignored." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x88c93dc9f68d24fc" ] pub struct GetDataTypeInfoRequest { # [ doc = " Ignored if 'name' is non-empty" ] pub id : u16 , # [ doc = " Ignored if 'name' is non-empty" ] pub kind : DataTypeKind , # [ doc = " Full data type name, e.g. \"uavcan.protocol.GetDataTypeInfo\"" ] pub name : :: Dynamic < [ u8 ; 80 ] > } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x88c93dc9f68d24fc" ] pub struct GetDataTypeInfoResponse { # [ doc = " Data type signature; valid only if the data type is known (see FLAG_KNOWN)" ] pub signature : u64 , # [ doc = " Valid only if the data type is known (see FLAG_KNOWN)" ] pub id : u16 , # [ doc = " Ditto" ] pub kind : DataTypeKind , pub flags : u8 , # [ doc = " Full data type name" ] pub name : :: Dynamic < [ u8 ; 80 ] > } impl :: uavcan_rs :: Request for GetDataTypeInfoRequest { type RESPONSE = GetDataTypeInfoResponse ; const TYPE_ID : Option < u8 > = Some ( 2 ) ; } impl :: uavcan_rs :: Response for GetDataTypeInfoResponse { type REQUEST = GetDataTypeInfoRequest ; const TYPE_ID : Option < u8 > = Some ( 2 ) ; } pub mod file { # [ doc = "" ] # [ doc = " Nested type." ] # [ doc = " Represents the type of the file system entry (e.g. file or directory)." ] # [ doc = " If such entry does not exist, 'flags' must be set to zero." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x6924572fbb2086e5" ] pub struct EntryType { pub flags : u8 } # [ doc = "" ] # [ doc = " Delete remote file system entry." ] # [ doc = " If the remote entry is a directory, all nested entries will be removed too." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x37184f4d5e898f0e" ] pub struct DeleteRequest { pub path : Path } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x37184f4d5e898f0e" ] pub struct DeleteResponse { pub error : Error } impl :: uavcan_rs :: Request for DeleteRequest { type RESPONSE = DeleteResponse ; const TYPE_ID : Option < u8 > = Some ( 47 ) ; } impl :: uavcan_rs :: Response for DeleteResponse { type REQUEST = DeleteRequest ; const TYPE_ID : Option < u8 > = Some ( 47 ) ; } # [ doc = "" ] # [ doc = " Nested type." ] # [ doc = " File operation result code." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xa83071ffea4fae15" ] pub struct Error { pub value : i16 } # [ doc = "" ] # [ doc = " Nested type." ] # [ doc = "" ] # [ doc = " File system path in UTF8." ] # [ doc = "" ] # [ doc = " The only valid separator is forward slash." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x12aefc50878a43e2" ] pub struct Path { pub path : :: Dynamic < [ u8 ; 200 ] > } # [ doc = "" ] # [ doc = " This service can be used to retrieve remote directory listing, one entry per request." ] # [ doc = "" ] # [ doc = " The client should query each entry independently, iterating 'entry_index' from 0 until the last entry is passed," ] # [ doc = " in which case the server will report that there is no such entry (via the fields 'entry_type' and 'error')." ] # [ doc = "" ] # [ doc = " The entry_index shall be applied to the ordered list of directory entries (e.g. alphabetically ordered). The exact" ] # [ doc = " sorting criteria does not matter as long as it provides the same ordering for subsequent service calls." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xcfb1184f8c28c684" ] pub struct GetDirectoryEntryInfoRequest { pub entry_index : u32 , pub directory_path : Path } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xcfb1184f8c28c684" ] pub struct GetDirectoryEntryInfoResponse { pub error : Error , pub entry_type : EntryType , # [ doc = " Ignored/Empty if such entry does not exist." ] pub entry_full_path : Path } impl :: uavcan_rs :: Request for GetDirectoryEntryInfoRequest { type RESPONSE = GetDirectoryEntryInfoResponse ; const TYPE_ID : Option < u8 > = Some ( 46 ) ; } impl :: uavcan_rs :: Response for GetDirectoryEntryInfoResponse { type REQUEST = GetDirectoryEntryInfoRequest ; const TYPE_ID : Option < u8 > = Some ( 46 ) ; } # [ doc = "" ] # [ doc = " Read file from a remote node." ] # [ doc = " " ] # [ doc = " There are two possible outcomes of a successful service call:" ] # [ doc = "  1. Data array size equals its capacity. This means that the end of the file is not reached yet." ] # [ doc = "  2. Data array size is less than its capacity, possibly zero. This means that the end of file is reached." ] # [ doc = " " ] # [ doc = " Thus, if the client needs to fetch the entire file, it should repeatedly call this service while increasing the" ] # [ doc = " offset, until incomplete data is returned." ] # [ doc = "" ] # [ doc = " If the object pointed by 'path' cannot be read (e.g. it is a directory or it does not exist), appropriate error code" ] # [ doc = " will be returned, and data array will be empty." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x182a9bbdfa6c8ca5" ] pub struct ReadRequest { pub offset : :: u40 , pub path : Path } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x182a9bbdfa6c8ca5" ] pub struct ReadResponse { pub error : Error , pub data : :: Dynamic < [ u8 ; 256 ] > } impl :: uavcan_rs :: Request for ReadRequest { type RESPONSE = ReadResponse ; const TYPE_ID : Option < u8 > = Some ( 48 ) ; } impl :: uavcan_rs :: Response for ReadResponse { type REQUEST = ReadRequest ; const TYPE_ID : Option < u8 > = Some ( 48 ) ; } # [ doc = "" ] # [ doc = " This service initiates firmware update on a remote node." ] # [ doc = "" ] # [ doc = " The node that is being updated (slave) will retrieve the firmware image file 'image_file_remote_path' from the node" ] # [ doc = " 'source_node_id' using the file read service, then it will update the firmware and reboot." ] # [ doc = "" ] # [ doc = " The slave can explicitly reject this request if it is not possible to update the firmware at the moment" ] # [ doc = " (e.g. if the node is busy)." ] # [ doc = "" ] # [ doc = " If the slave node accepts this request, the initiator will get a response immediately, before the update process" ] # [ doc = " actually begins." ] # [ doc = "" ] # [ doc = " While the firmware is being updated, the slave should set its mode (uavcan.protocol.NodeStatus.mode) to" ] # [ doc = " MODE_SOFTWARE_UPDATE." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x36a8b8aa5453257b" ] pub struct BeginFirmwareUpdateRequest { # [ doc = " If this field is zero, the caller's Node ID will be used instead." ] pub source_node_id : u8 , pub image_file_remote_path : Path } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x36a8b8aa5453257b" ] pub struct BeginFirmwareUpdateResponse { # [ doc = "" ] # [ doc = " Other error codes may be added in the future." ] # [ doc = "" ] pub error : u8 , # [ doc = " Detailed description of the error." ] pub optional_error_message : :: Dynamic < [ u8 ; 127 ] > } impl :: uavcan_rs :: Request for BeginFirmwareUpdateRequest { type RESPONSE = BeginFirmwareUpdateResponse ; const TYPE_ID : Option < u8 > = Some ( 40 ) ; } impl :: uavcan_rs :: Response for BeginFirmwareUpdateResponse { type REQUEST = BeginFirmwareUpdateRequest ; const TYPE_ID : Option < u8 > = Some ( 40 ) ; } # [ doc = "" ] # [ doc = " Request info about a remote file system entry (file, directory, etc)." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xcfbbc571f4fdb19e" ] pub struct GetInfoRequest { pub path : Path } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xcfbbc571f4fdb19e" ] pub struct GetInfoResponse { # [ doc = "" ] # [ doc = " File size in bytes." ] # [ doc = " Should be set to zero for directories." ] # [ doc = "" ] pub size : :: u40 , pub error : Error , pub entry_type : EntryType } impl :: uavcan_rs :: Request for GetInfoRequest { type RESPONSE = GetInfoResponse ; const TYPE_ID : Option < u8 > = Some ( 45 ) ; } impl :: uavcan_rs :: Response for GetInfoResponse { type REQUEST = GetInfoRequest ; const TYPE_ID : Option < u8 > = Some ( 45 ) ; } # [ doc = "" ] # [ doc = " Write into a remote file." ] # [ doc = " The server shall place the contents of the field 'data' into the file pointed by 'path' at the offset specified by" ] # [ doc = " the field 'offset'." ] # [ doc = "" ] # [ doc = " When writing a file, the client should repeatedly call this service with data while advancing offset until the file" ] # [ doc = " is written completely. When write is complete, the client shall call the service one last time, with the offset" ] # [ doc = " set to the size of the file and with the data field empty, which will signal the server that the write operation is" ] # [ doc = " complete." ] # [ doc = "" ] # [ doc = " When the write operation is complete, the server shall truncate the resulting file past the specified offset." ] # [ doc = "" ] # [ doc = " Server implementation advice:" ] # [ doc = " It is recommended to implement proper handling of concurrent writes to the same file from different clients, for" ] # [ doc = " example by means of creating a staging area for uncompleted writes (like FTP servers do)." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xdc262f0a3a3fbd75" ] pub struct WriteRequest { pub offset : :: u40 , pub path : Path , pub data : :: Dynamic < [ u8 ; 192 ] > } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xdc262f0a3a3fbd75" ] pub struct WriteResponse { pub error : Error } impl :: uavcan_rs :: Request for WriteRequest { type RESPONSE = WriteResponse ; const TYPE_ID : Option < u8 > = Some ( 49 ) ; } impl :: uavcan_rs :: Response for WriteResponse { type REQUEST = WriteRequest ; const TYPE_ID : Option < u8 > = Some ( 49 ) ; } } pub mod param { # [ doc = "" ] # [ doc = " Service to control the node configuration." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x3b131ac5eb69d2cd" ] pub struct ExecuteOpcodeRequest { # [ doc = "" ] # [ doc = " SAVE operation instructs the remote node to save the current configuration parameters into a non-volatile" ] # [ doc = " storage. The node may require a restart in order for some changes to take effect." ] # [ doc = "" ] # [ doc = " ERASE operation instructs the remote node to clear its configuration storage and reinitialize the parameters" ] # [ doc = " with their default values. The node may require a restart in order for some changes to take effect." ] # [ doc = "" ] # [ doc = " Other opcodes may be added in the future (for example, an opcode for switching between multiple configurations)." ] # [ doc = "" ] pub opcode : u8 , # [ doc = "" ] # [ doc = " Reserved, keep zero." ] # [ doc = "" ] pub argument : :: i48 } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x3b131ac5eb69d2cd" ] pub struct ExecuteOpcodeResponse { # [ doc = "" ] # [ doc = " If 'ok' (the field below) is true, this value is not used and must be kept zero." ] # [ doc = " If 'ok' is false, this value may contain error code. Error code constants may be defined in the future." ] # [ doc = "" ] pub argument : :: i48 , # [ doc = "" ] # [ doc = " True if the operation has been performed successfully, false otherwise." ] # [ doc = "" ] pub ok : bool } impl :: uavcan_rs :: Request for ExecuteOpcodeRequest { type RESPONSE = ExecuteOpcodeResponse ; const TYPE_ID : Option < u8 > = Some ( 10 ) ; } impl :: uavcan_rs :: Response for ExecuteOpcodeResponse { type REQUEST = ExecuteOpcodeRequest ; const TYPE_ID : Option < u8 > = Some ( 10 ) ; } # [ doc = "" ] # [ doc = " Numeric-only value." ] # [ doc = "" ] # [ doc = " This is a union, which means that this structure can contain either one of the fields below." ] # [ doc = " The structure is prefixed with tag - a selector value that indicates which particular field is encoded." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x1222eea596ad701c" ] pub enum NumericValue { # [ doc = " Empty field, used to represent an undefined value." ] Empty ( Empty ) , IntegerValue ( i64 ) , RealValue ( f32 ) , } # [ doc = "" ] # [ doc = " Ex nihilo nihil fit." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xd5f3ead2bddc1f0" ] pub struct Empty { } # [ doc = "" ] # [ doc = " Single parameter value." ] # [ doc = "" ] # [ doc = " This is a union, which means that this structure can contain either one of the fields below." ] # [ doc = " The structure is prefixed with tag - a selector value that indicates which particular field is encoded." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xc3d96f448f2b00a1" ] pub enum Value { # [ doc = " Empty field, used to represent an undefined value." ] Empty ( Empty ) , IntegerValue ( i64 ) , # [ doc = " 32-bit type is used to simplify implementation on low-end systems" ] RealValue ( f32 ) , # [ doc = " 8-bit value is used for alignment reasons" ] BooleanValue ( u8 ) , # [ doc = " Length prefix is exactly one byte long, which ensures proper alignment of payload" ] StringValue ( :: Dynamic < [ u8 ; 128 ] > ) , } # [ doc = "" ] # [ doc = " Get or set a parameter by name or by index." ] # [ doc = " Note that access by index should only be used to retreive the list of parameters; it is higly" ] # [ doc = " discouraged to use it for anything else, because persistent ordering is not guaranteed." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xb7d14152f13221ed" ] pub struct GetSetRequest { # [ doc = "" ] # [ doc = " Index of the parameter starting from 0; ignored if name is nonempty." ] # [ doc = " Use index only to retrieve the list of parameters." ] # [ doc = " Parameter ordering must be well defined (e.g. alphabetical, or any other stable ordering)," ] # [ doc = " in order for the index access to work." ] # [ doc = "" ] pub index : :: u13 , # [ doc = "" ] # [ doc = " If set - parameter will be assigned this value, then the new value will be returned." ] # [ doc = " If not set - current parameter value will be returned." ] # [ doc = " Refer to the definition of Value for details." ] # [ doc = "" ] pub value : Value , # [ doc = "" ] # [ doc = " Name of the parameter; always preferred over index if nonempty." ] # [ doc = "" ] pub name : :: Dynamic < [ u8 ; 92 ] > } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xb7d14152f13221ed" ] pub struct GetSetResponse { pub _v0 : :: void5 , # [ doc = "" ] # [ doc = " Actual parameter value." ] # [ doc = "" ] # [ doc = " For set requests, it should contain the actual parameter value after the set request was" ] # [ doc = " executed. The objective is to let the client know if the value could not be updated, e.g." ] # [ doc = " due to its range violation, etc." ] # [ doc = "" ] # [ doc = " Empty value (and/or empty name) indicates that there is no such parameter." ] # [ doc = "" ] pub value : Value , pub _v1 : :: void5 , # [ doc = " Optional" ] pub default_value : Value , pub _v2 : :: void6 , # [ doc = " Optional, not applicable for bool/string" ] pub max_value : NumericValue , pub _v3 : :: void6 , # [ doc = " Optional, not applicable for bool/string" ] pub min_value : NumericValue , # [ doc = "" ] # [ doc = " Empty name (and/or empty value) in response indicates that there is no such parameter." ] # [ doc = "" ] pub name : :: Dynamic < [ u8 ; 92 ] > } impl :: uavcan_rs :: Request for GetSetRequest { type RESPONSE = GetSetResponse ; const TYPE_ID : Option < u8 > = Some ( 11 ) ; } impl :: uavcan_rs :: Response for GetSetResponse { type REQUEST = GetSetRequest ; const TYPE_ID : Option < u8 > = Some ( 11 ) ; } } pub mod enumeration { # [ doc = "" ] # [ doc = " This message will be broadcasted when the node receives user input in the process of enumeration." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xf4c6258908fd263b" ] pub struct Indication { pub _v0 : :: void6 , # [ doc = "" ] # [ doc = " This field is unused; keep it empty" ] # [ doc = "" ] pub value : :: uavcan :: protocol :: param :: NumericValue , # [ doc = "" ] # [ doc = " Name of the enumerated parameter." ] # [ doc = " This field must always be populated by the enumeratee." ] # [ doc = " If multiple parameters were enumerated at once (e.g. ESC index and the direction of rotation)," ] # [ doc = " the field should contain the name of the most important parameter." ] # [ doc = "" ] pub parameter_name : :: Dynamic < [ u8 ; 92 ] > } impl :: uavcan_rs :: Message for Indication { const TYPE_ID : Option < u16 > = Some ( 380 ) ; } # [ doc = "" ] # [ doc = " This service instructs the node to begin the process of automated enumeration." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x196ae06426a3b5d8" ] pub struct BeginRequest { # [ doc = "" ] # [ doc = " The node will automatically leave enumeration mode upon expiration of this timeout." ] # [ doc = "" ] # [ doc = " [Seconds]" ] pub timeout_sec : u16 , # [ doc = "" ] # [ doc = " Name of the parameter to enumerate, e.g. ESC index." ] # [ doc = " If the name is left empty, the node will infer the parameter name automatically (autodetect)." ] # [ doc = " It is highly recommended to always use autodetection in order to avoid dependency on hard-coded parameter names," ] # [ doc = " and also allow the enumeratee to possibly enumerate multiple different parameters at once." ] # [ doc = " The rule of thumb is to always leave this parameter empty unless you really know what you're doing." ] # [ doc = "" ] pub parameter_name : :: Dynamic < [ u8 ; 92 ] > } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x196ae06426a3b5d8" ] pub struct BeginResponse { pub error : u8 } impl :: uavcan_rs :: Request for BeginRequest { type RESPONSE = BeginResponse ; const TYPE_ID : Option < u8 > = Some ( 15 ) ; } impl :: uavcan_rs :: Response for BeginResponse { type REQUEST = BeginRequest ; const TYPE_ID : Option < u8 > = Some ( 15 ) ; } } pub mod debug { # [ doc = "" ] # [ doc = " Generic log message." ] # [ doc = " All items are byte aligned." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xe9862b78d38762ba" ] pub struct LogMessage { pub level : LogLevel , pub source : :: Dynamic < [ u8 ; 31 ] > , pub text : :: Dynamic < [ u8 ; 90 ] > } impl :: uavcan_rs :: Message for LogMessage { const TYPE_ID : Option < u16 > = Some ( 16383 ) ; } # [ doc = "" ] # [ doc = " Generic named parameter (key/value pair)." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xe02f25d6e0c98ae0" ] pub struct KeyValue { # [ doc = "" ] # [ doc = " Integers are exactly representable in the range (-2^24, 2^24) which is (-16'777'216, 16'777'216)." ] # [ doc = "" ] pub value : f32 , # [ doc = "" ] # [ doc = " Tail array optimization is enabled, so if key length does not exceed 3 characters, the whole" ] # [ doc = " message can fit into one CAN frame. The message always fits into one CAN FD frame." ] # [ doc = "" ] pub key : :: Dynamic < [ u8 ; 58 ] > } impl :: uavcan_rs :: Message for KeyValue { const TYPE_ID : Option < u16 > = Some ( 16370 ) ; } # [ doc = "" ] # [ doc = " Log message severity" ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x711bf141af572346" ] pub struct LogLevel { pub value : :: u3 } } # [ doc = "" ] # [ doc = " Get transport statistics." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x31c7f654531b61b3" ] pub struct GetTransportStatsRequest { } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x31c7f654531b61b3" ] pub struct GetTransportStatsResponse { # [ doc = "" ] # [ doc = " UAVCAN transport layer statistics." ] # [ doc = "" ] # [ doc = " Number of transmitted transfers." ] pub transfers_tx : :: u48 , # [ doc = " Number of received transfers." ] pub transfers_rx : :: u48 , # [ doc = " Number of errors detected in the UAVCAN transport layer." ] pub transfer_errors : :: u48 , # [ doc = "" ] # [ doc = " CAN bus statistics, for each interface independently." ] # [ doc = "" ] pub can_iface_stats : :: Dynamic < [ CANIfaceStats ; 3 ] > } impl :: uavcan_rs :: Request for GetTransportStatsRequest { type RESPONSE = GetTransportStatsResponse ; const TYPE_ID : Option < u8 > = Some ( 4 ) ; } impl :: uavcan_rs :: Response for GetTransportStatsResponse { type REQUEST = GetTransportStatsRequest ; const TYPE_ID : Option < u8 > = Some ( 4 ) ; } # [ doc = "" ] # [ doc = " Nested type." ] # [ doc = " Generic hardware version information." ] # [ doc = " These values should remain unchanged for the device's lifetime." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xad5c4c933f4a0c4" ] pub struct HardwareVersion { # [ doc = "" ] # [ doc = " Hardware version code." ] # [ doc = "" ] pub major : u8 , pub minor : u8 , # [ doc = "" ] # [ doc = " Unique ID is a 128 bit long sequence that is globally unique for each node." ] # [ doc = " All zeros is not a valid UID." ] # [ doc = " If filled with zeros, assume that the value is undefined." ] # [ doc = "" ] pub unique_id : [ u8 ; 16 ] , # [ doc = "" ] # [ doc = " Certificate of authenticity (COA) of the hardware, 255 bytes max." ] # [ doc = "" ] pub certificate_of_authenticity : :: Dynamic < [ u8 ; 255 ] > } # [ doc = "" ] # [ doc = " Nested type." ] # [ doc = " Generic software version information." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xdd46fd376527fea1" ] pub struct SoftwareVersion { # [ doc = "" ] # [ doc = " Primary version numbers." ] # [ doc = " If both fields are set to zero, the version is considered unknown." ] # [ doc = "" ] pub major : u8 , pub minor : u8 , # [ doc = "" ] # [ doc = " This mask indicates which optional fields (see below) are set." ] # [ doc = "" ] pub optional_field_flags : u8 , # [ doc = "" ] # [ doc = " VCS commit hash or revision number, e.g. git short commit hash. Optional." ] # [ doc = "" ] pub vcs_commit : u32 , # [ doc = "" ] # [ doc = " The value of an arbitrary hash function applied to the firmware image." ] # [ doc = " This field is used to detect whether the firmware running on the node is EXACTLY THE SAME" ] # [ doc = " as a certain specific revision. This field provides the absolute identity guarantee, unlike" ] # [ doc = " the version fields above, which can be the same for different builds of the firmware." ] # [ doc = "" ] # [ doc = " The exact hash function and the methods of its application are implementation defined." ] # [ doc = " However, implementations are recommended to adhere to the following guidelines," ] # [ doc = " fully or partially:" ] # [ doc = "" ] # [ doc = "   - The hash function should be CRC-64-WE, the same that is used for computing DSDL signatures." ] # [ doc = "" ] # [ doc = "   - The hash function should be applied to the entire application image padded to 8 bytes." ] # [ doc = "" ] # [ doc = "   - If the computed image CRC is stored within the firmware image itself, the value of" ] # [ doc = "     the hash function becomes ill-defined, because it becomes recursively dependent on itself." ] # [ doc = "     In order to circumvent this issue, while computing or checking the CRC, its value stored" ] # [ doc = "     within the image should be zeroed out." ] # [ doc = "" ] pub image_crc : u64 } # [ doc = "" ] # [ doc = " Single CAN iface statistics." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x13b106f0c44ca350" ] pub struct CANIfaceStats { # [ doc = " Number of transmitted CAN frames." ] pub frames_tx : :: u48 , # [ doc = " Number of received CAN frames." ] pub frames_rx : :: u48 , # [ doc = " Number of errors in the CAN layer." ] pub errors : :: u48 } # [ doc = "" ] # [ doc = " THIS DEFINITION IS SUBJECT TO CHANGE." ] # [ doc = "" ] # [ doc = " This service allows to execute arbitrary commands on the remote node's internal system shell." ] # [ doc = "" ] # [ doc = " Essentially, this service mimics a typical terminal emulator, with one text input (stdin) and two text" ] # [ doc = " outputs (stdout and stderr). When there's no process running, the input is directed into the terminal" ] # [ doc = " handler itself, which interpretes it. If there's a process running, the input will be directed into" ] # [ doc = " stdin of the running process. It is possible to forcefully return the terminal into a known state by" ] # [ doc = " means of setting the reset flag (see below), in which case the terminal will kill all of the child" ] # [ doc = " processes, if any, and return into the initial idle state." ] # [ doc = "" ] # [ doc = " The server is assumed to allocate one independent terminal instance per client, so that different clients" ] # [ doc = " can execute commands without interfering with each other." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x59276b5921c9246e" ] pub struct AccessCommandShellRequest { # [ doc = "" ] # [ doc = " These flags control the shell and command execution." ] # [ doc = "" ] pub flags : u8 , # [ doc = "" ] # [ doc = " If the shell is idle, it will interpret this string." ] # [ doc = " If there's a process running, this string will be piped into its stdin." ] # [ doc = "" ] # [ doc = " If RESET_SHELL is set, new input will be interpreted by the shell immediately." ] # [ doc = "" ] pub input : :: Dynamic < [ u8 ; 128 ] > } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x59276b5921c9246e" ] pub struct AccessCommandShellResponse { # [ doc = "" ] # [ doc = " Exit status of the last executed process, or error code of the shell itself." ] # [ doc = " Default value is zero." ] # [ doc = "" ] pub last_exit_status : i32 , # [ doc = "" ] # [ doc = " These flags indicate the status of the shell." ] # [ doc = "" ] pub flags : u8 , # [ doc = "" ] # [ doc = " In case of a shell error, this string may contain ASCII string explaining the nature of the error." ] # [ doc = " Otherwise, if stdout read is requested, this string will contain stdout data. If stderr read is requested," ] # [ doc = " this string will contain stderr data. If both stdout and stderr read is requested, this string will start" ] # [ doc = " with stdout and end with stderr, with no separator in between." ] # [ doc = "" ] pub output : :: Dynamic < [ u8 ; 256 ] > } impl :: uavcan_rs :: Request for AccessCommandShellRequest { type RESPONSE = AccessCommandShellResponse ; const TYPE_ID : Option < u8 > = Some ( 6 ) ; } impl :: uavcan_rs :: Response for AccessCommandShellResponse { type REQUEST = AccessCommandShellRequest ; const TYPE_ID : Option < u8 > = Some ( 6 ) ; } # [ doc = "" ] # [ doc = " Abstract node status information." ] # [ doc = "" ] # [ doc = " Any UAVCAN node is required to publish this message periodically." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xf0868d0c1a7c6f1" ] pub struct NodeStatus { # [ doc = "" ] # [ doc = " Uptime counter should never overflow." ] # [ doc = " Other nodes may detect that a remote node has restarted when this value goes backwards." ] # [ doc = "" ] pub uptime_sec : u32 , # [ doc = "" ] # [ doc = " Abstract node health." ] # [ doc = "" ] pub health : :: u2 , # [ doc = "" ] # [ doc = " Current mode." ] # [ doc = "" ] # [ doc = " Mode OFFLINE can be actually reported by the node to explicitly inform other network" ] # [ doc = " participants that the sending node is about to shutdown. In this case other nodes will not" ] # [ doc = " have to wait OFFLINE_TIMEOUT_MS before they detect that the node is no longer available." ] # [ doc = "" ] # [ doc = " Reserved values can be used in future revisions of the specification." ] # [ doc = "" ] pub mode : :: u3 , # [ doc = "" ] # [ doc = " Not used currently, keep zero when publishing, ignore when receiving." ] # [ doc = "" ] pub sub_mode : :: u3 , # [ doc = "" ] # [ doc = " Optional, vendor-specific node status code, e.g. a fault code or a status bitmask." ] # [ doc = "" ] pub vendor_specific_status_code : u16 } impl :: uavcan_rs :: Message for NodeStatus { const TYPE_ID : Option < u16 > = Some ( 341 ) ; } # [ doc = "" ] # [ doc = " This message may be published periodically to inform network participants that the system has encountered" ] # [ doc = " an unrecoverable fault and is not capable of further operation." ] # [ doc = "" ] # [ doc = " Nodes that are expected to react to this message should wait for at least MIN_MESSAGES subsequent messages" ] # [ doc = " with any reason text from any sender published with the interval no higher than MAX_INTERVAL_MS before" ] # [ doc = " undertaking any emergency actions." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x8b79b4101811c1d7" ] pub struct Panic { # [ doc = "" ] # [ doc = " Short description that would fit a single CAN frame." ] # [ doc = "" ] pub reason_text : :: Dynamic < [ u8 ; 7 ] > } impl :: uavcan_rs :: Message for Panic { const TYPE_ID : Option < u16 > = Some ( 5 ) ; } # [ doc = "" ] # [ doc = " Global time synchronization." ] # [ doc = " Any node that publishes timestamped data must use this time reference." ] # [ doc = "" ] # [ doc = " Please refer to the specification to learn about the synchronization algorithm." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x20271116a793c2db" ] pub struct GlobalTimeSync { # [ doc = "" ] # [ doc = " Time in microseconds when the PREVIOUS GlobalTimeSync message was transmitted." ] # [ doc = " If this message is the first one, this field must be zero." ] # [ doc = "" ] # [ doc = " Microseconds" ] pub previous_transmission_timestamp_usec : :: u56 } impl :: uavcan_rs :: Message for GlobalTimeSync { const TYPE_ID : Option < u16 > = Some ( 4 ) ; } # [ doc = "" ] # [ doc = " Data type kind (message or service)." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0x9420a73e008e5930" ] pub struct DataTypeKind { pub value : u8 } # [ doc = "" ] # [ doc = " Full node info request." ] # [ doc = " Note that all fields of the response section are byte-aligned." ] # [ doc = "" ] # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xa80dc8995053e685" ] pub struct GetNodeInfoRequest { } # [ derive ( Debug , Clone , UavcanStruct ) ] # [ UavcanCrateName = "uavcan_rs" ] # [ DSDLSignature = "0xa80dc8995053e685" ] pub struct GetNodeInfoResponse { # [ doc = "" ] # [ doc = " Current node status" ] # [ doc = "" ] pub status : NodeStatus , # [ doc = "" ] # [ doc = " Version information shall not be changed while the node is running." ] # [ doc = "" ] pub software_version : SoftwareVersion , pub hardware_version : HardwareVersion , # [ doc = "" ] # [ doc = " Human readable non-empty ASCII node name." ] # [ doc = " Node name shall not be changed while the node is running." ] # [ doc = " Empty string is not a valid node name." ] # [ doc = " Allowed characters are: a-z (lowercase ASCII letters) 0-9 (decimal digits) . (dot) - (dash) _ (underscore)." ] # [ doc = " Node name is a reversed internet domain name (like Java packages), e.g. \"com.manufacturer.project.product\"." ] # [ doc = "" ] pub name : :: Dynamic < [ u8 ; 80 ] > } impl :: uavcan_rs :: Request for GetNodeInfoRequest { type RESPONSE = GetNodeInfoResponse ; const TYPE_ID : Option < u8 > = Some ( 1 ) ; } impl :: uavcan_rs :: Response for GetNodeInfoResponse { type REQUEST = GetNodeInfoRequest ; const TYPE_ID : Option < u8 > = Some ( 1 ) ; } } }